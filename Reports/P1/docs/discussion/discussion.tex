\chapter{Discussion}

In this chapter the technical results of the project are analyzed. First, the design verification is performed, comparing the simulation and the experimental results. Then, the main drawbacks found through the project and limitations of the converter are explained. Finally, suggestions for future work are presented.

\section{Verification of experimental results} \label{Experiment_verification}
In this section the experimental results from the open-loop and MPPT test in section \ref{systemtest} are compared with the simulation results from section \ref{sec:componentsizing} and \ref{MPPTSimulation}.

\subsection{Open-loop simulation} \label{ol_discussion}

%The main losses are the dissipation from the component in heat. Also the load is a power resistor and it changes the resistance if it is in operation. So we have not a constant load at the output as in the simulation. Another reason is the dead-time of the MOSFET and therefore the duty cycle is not exactly the same value as in the simulation. belongs to the topic between efficiency simulationa and result

The table \ref{tab:ripple} compares the values of the ripples from the experiments with the values from the requirements in section \ref{sec:componentsizing} and the simulation results in appendix \ref{app:OL_ripple}. 
\todo{check after tests are performed.}
From the experimental results the signal is noisy and the ripple are to small (or cannot be detected)to capture values from the figure. 

The simulation result of the inductor and output voltage ripple have the same value as those stated in the system requirement. This means the component have been selected correctly. 
In both cases, the experimental results for the ripples are smaller than in the simulation. The used output capacitor is oversized by a factor of ten and thus the ripple should be ten times smaller than the calculated one, as shown in table \ref{tab:ripple}. Also, the output ripple was tested in buck mode instead of boost mode due to malfunctioning of MOSFET 4 driver. This is not the worst case for the output voltage ripple.

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{3.5cm}|p{3cm}|p{3cm}|p{3cm}|}
		\hline
		\rowcolor{lightgray} \textbf{} & \textbf{Requirement} & \textbf{Simulation}  & \textbf{Experiment}   \tabularnewline \hline
		$\Delta V_{in}$ & 0.1\% & 0.099\% & - \tabularnewline \hline
		$\Delta I_{L}$ & 10\% & 10.0\% & 9.86\% \tabularnewline \hline
		$\Delta V_{out}$  & 0.5\% & 0.500\% & 0.055\% \tabularnewline \hline
	\end{tabular}
	\caption{Voltage and current ripple.}
	\label{tab:ripple}
\end{table}

\subsection{Maximum power point tracking} \label{MPPT_discussion}

The proposed Perturb and Observe algorithm was simulated and also tested in the PV lab to show its real performance. The simulation was implemented in PLECS beccause this software allows to program easily the C-code for the MPPT algorithm. The results obtained showed MPPT's efficiencies higher than 99\% for the different levels of irradiance and temperature. As mention in previous chapters, the MPPT algorithm was designed with the objective of increasing the power generated by the PV panel. This was achieved in simulations together with fast MPP tracking and low oscillations around the MPP. 

Table \ref{tab:comparisonMPPT} shows the simulated results together with the experimental results for STC. The experimental results show that the MPPT's efficiency is higher than 97\%. Therefore, the performance of the proposed P\&O algorithm is in the rate of the most common MPPT algorithm which varies between 96\% and 99\% \cite{MPPTResearch}. For the case of the conventional P\&O algorithm, the MPPT's efficiency is around 96\% \cite{MPPTResearch}. Hence, the modifications applied to the conventional P\&O algorithm allowed to improve the MPPT's performance. 

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{2.3cm}|>{\centering}p{2.3cm}|>{\centering}p{2.3cm}|>{\centering}p{2.3cm}|>{\centering}p{2.3cm}|}
		\hline
		\rowcolor{lightgray}\multicolumn{5}{|l|}{ \textbf{Standard Test Conditions (STC)}} \\ \hline
		 \rowcolor{lightgray} & \multicolumn{2}{|c|}{ \textbf{Buck Mode}} & \multicolumn{2}{|c|}{ \textbf{Boost Mode}} \tabularnewline \hline
		\rowcolor{lightgray} \textbf{} & \textbf{Simulation}  & \textbf{Experiment} & \textbf{Simulation}  & \textbf{Experiment}  \tabularnewline \hline
		$\eta_{MPPT}$ & 99.96 \% & 97.72 \% & 99.82 \% & 97.32 \% \tabularnewline \hline
		$t_{MPPT}$ & 2 s & 10 s & 4 s & 21 s \tabularnewline \hline
	\end{tabular}
	\caption{Simulated and experimental results for the P\&O MPPT algorithm under STC.}
	\label{tab:comparisonMPPT}
\end{table}

Comparing the experimental results with the simulated ones, from table \ref{tab:comparisonMPPT}, it is seen that the time the MPPT takes to reach the MPP is five times higher than in simulation, this is most likely due to noise and ripple on the measurements. On the other hand, by comparing the efficiency of the MPPT algorithm, it is seen that the error is  2.24\% and 2.5\% for buck and boost mode, respectively. With these results, the P\&O algorithm is considered accurate enough to validate its performance under STC.

The second test was performed to observe the behavior of the MPPT algorithm under sudden changes in irradiance and temperature. Table \ref{tab:comparisonMPPTchanges} shows that, in the case of change in irradiance, by keeping constant the temperature to 25$\decC$, the measured MPPT's efficiency is reduced. The maximum error is achieved when the P\&O is tracking the corresponding MPP for 800$W/m^2$. The error is, in this case, 5.92\%. It is also observed that in simulation the response time is much lower than under STC. However, the time ratio between simulation and test is 13.2 in this case. For the sudden change in temperature, by keeping constant the irradiance to 1000$W/m^2$, the MPPT's performance is considerably improved. The maximum error is 1.5\%. Moreover, a faster MPP tracking is achieved in this case. 

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{2.3cm}|>{\centering}p{5cm}|>{\centering}p{5cm}|}
		\hline
		\rowcolor{lightgray}\multicolumn{3}{|l|}{ \textbf{Change in irradiance and constant temperature}} \\ \hline
		\rowcolor{lightgray} & \multicolumn{1}{|c|}{ \textbf{Simulation}} & \multicolumn{1}{|c|}{ \textbf{Experiment}} \tabularnewline \hline
		$\eta_{MPPT}$ & From 99.81\% to 99.70\% & From 95.96\% to 93.78\% \tabularnewline \hline
		$t_{MPPT}$ & 0.5 s  & 6.6 s \tabularnewline \hline
		\rowcolor{lightgray}\multicolumn{3}{|l|}{ \textbf{Change in temperature and constant irradiance}} \\ \hline
		\rowcolor{lightgray} & \multicolumn{1}{|c|}{ \textbf{Simulation}} & \multicolumn{1}{|c|}{ \textbf{Experiment}} \tabularnewline \hline
		$\eta_{MPPT}$ & From 99.81\% to 99.90\% & From 99.20\% to 98.40\%
		\tabularnewline \hline
		$t_{MPPT}$ & 2 s  & 4.1 s \tabularnewline \hline
	\end{tabular}
	\caption{Simulated and experimental results for the P\&O MPPT algorithm under sudden change in irradiance (1000-800$W/m^2$) and temperature (25-15$\decC$) in buck mode ($R_{L}=3\Omega$).}
	\label{tab:comparisonMPPTchanges}
\end{table}

\section{Problems and limitations}
%3-Explain main problems and limitations and how are handled. Be succinct, be frank but no apologetic. Explain implications of limitations.
%\subsection{Layout improvement procedure and issues, title to be improved}
%opto <--x-->driver voltage levels?

%inductor saturation and so

%pcb hot points
\todo{Add intro.}

\input{docs/discussion/outputCap.tex}

\input{docs/discussion/coil.tex}

\input{docs/discussion/driver.tex}

\subsection{MPPT algorithm}
The embedded control system requires the algorithm to work properly. During the development process, the code might not behave as intended. A common way of supporting the debugging process consists of the use of breakpoints. 
The code can then be stopped and the variables' value might be read. However, this feature is not supported by the used platform. In the case of controlling physical systems, the use of breakpoints would be limited to simulation. Then alternative techniques had to be used. 
The adopted approach consisted on outputting the FSMs' state and relevant values for the current state at every code execution loop. 
The 'Timestamp' field is specially important during simulation in order to track events at specific times. See figure \ref{console_output}.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{../Pictures/P1/Discussion/console_output.png}
		\caption{Console output.}
		\label{console_output}
	\end{center}	
\end{figure}

In initial implementations of the control algorithm, the voltage evaluation was performed in the state after the duty cycle change. 
After this change, the system experiences a transient stage where the input voltage and inductor current evolve into the new steady state value. If these variables are read during the transient, the control might infer that the PV panel is in a location of the P-V curve different from where it actually is. 
The MPPT becomes noisier under this scenario. In order to address this issue, an additional waiting state was added to the FSM governing the system. 
Another solution to the issue would be to decrease the MPPT algorithm periodicity. However this solution would lead to a decrease in system's responsiveness. This drawback might be bearable by implementing a voltage controller aside from the MPPT.  

The noise in measured signals highly influenced the algorithm performance. This noise was addressed by software low pass filtering. The filter caused a dramatic improvement in signal acquisition and system response, further details are explained in the next section.

In order to develop a completely reliable algorithm further testing must be performed. These tests require more advanced debugging information than the console output previously shown. RT Box allows SPI communication but the testing activities would still be limited to black-box techniques. In order to reach white-box testing, the implementation would require a microcontroller instead of the RT-box. If that was the case, the variables' value might be directly accessed with a debugger. Also in the case of black-box testing, the signals are sent with a known and fixed latency by the microcontroller, which is not the case when using PLECS's console.

The implemented algorithm has more advanced functions than the simplest implementation found in introductory application notes from manufacturers \cite{AN1521_MC}. 
Among the advanced functions, threshold parameters are tunable, waiting for the PV to reach open circuit voltage or variable perturb step, among others. However, these additional features add difficulty to the tests and code comprehension. Under the development of a commercial product, it might be desirable to limit the features in order to decrease test and validation cost. The decrease of the perturb variable consists of a FSM with 5 states with a weak coupling with the main FSM.

The proposed implementation has some variables which might be further optimized, like the initial value or the threshold to decrease the perturb step. 


\subsection{Software filter}
Although the voltage and current measurement is hardware filtered, the signal read by the control system was noisy. This affected the MPPT algorithm, disturbing its ability to reach the MPP. There are many techniques in order to address noise issues, the used technique consists in the use of a low pass digital filter. The result can be seen in \ref{software_filter}. It consists of a single pole low pass filter. Its corner frequency is set as the same of the hardware filters, 50 Hz. In order to design the software filter, explanations from \cite{digital_filter} have been followed.

First, the execution frequency of the filter $f_{filter}$ is defined. It is set to $20 kHz$, this frequency is low enough to have a low CPU consumption, according to RT Box estimation. Now, $\tau$ must be calculated, as seen in equation \ref{tau_calculation}. 

\begin{equation} \label{tau_calculation}
\tau= \dfrac{1}{2\pi \cdot f_c} = 3.18 ms
\end{equation}

The implemented single pole low pass filter has the recursive equation explained in \ref{filter_recursive_eq}. The parameters $a_0 $ and $b_1$ must be found. 

\begin{equation} \label{filter_recursive_eq}
y_n= x_n \cdot a_0 + y_{n-1} \cdot b_1
\end{equation}

First, $b_1$ is calculated as explained in \ref{b1_calc}. Then $a_0$ is easily calculated as shown in \ref{a0_calc}.

\begin{equation} \label{b1_calc}
b_1=  e^{\frac{-1}{f_{filter} \cdot \tau}} = e^{\frac{-1}{20 \times 10^{3} \cdot 3.18 \times 10^{-3}}} = 0.9843
\end{equation}

\begin{equation} \label{a0_calc}
a_0=  1 - b_1 = 0.0156
\end{equation}

The design is validated by analysing the step response of the filter. The result can be seen in figure \ref{step_response_filter}. $\tau$ is confirmed, reaching around $63\%$ of the value in the required time. Cursor one is fixed at the beginning of the step and cursor 2 is set at $0.6327$, the time difference is $3.25 ms$. 

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=\textwidth]{../Pictures/P1/Discussion/filter_step_response.png}
		\caption{Step response of the designed filter.}
		\label{step_response_filter}
	\end{center}	
\end{figure}

\todo{new content}

The tested result can be seen in figure \ref{software_filter}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.8\textwidth]{../Pictures/P1/Discussion/sw_filter_current_new.png}
		\caption{Current measurement against time. Both software filtered (blue) and raw (red) signals can be seen. The filtered signal data points' size has been increased to improve readability.}
		\label{software_filter}
	\end{center}	
\end{figure}

\input{docs/discussion/futureWork.tex}




