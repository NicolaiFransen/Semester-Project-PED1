\chapter{Discussion}

\todo{
	**Things to avoid
	2Hyping findings-
	3Interpreting beyond what can be justified-
	4Extend in tangential topics-}

1-Intro - to be written when the section is more mature

2-What have we done:  a paragraph or two explaining the major findings and why are important.

\section{Validation of experimental results}
\subsection{Open loop simulation}
\todo{This was written in chapter 6.}
The main losses are the dissipation from the component in heat. Also the load is a power resistor and it changes the resistance if it is in operation. So we have not a constant load at the output as in the simulation. Another reason is the dead-time of the MOSFET and therefore the duty cycle is not exactly the same value as in the simulation. 

The table \ref{tab:ripple} compares the values of the ripples from the experiments with the values from the requirements in section \ref{sec:componentsizing} and the simulation results in appendix \ref{app:OL_ripple}. So in all three cases the measured ripples from the experiment are higher/lower than the values from the requirement. Here the reason.

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{3.5cm}|p{3cm}|p{3cm}|p{3cm}|}
		\hline
		\rowcolor{lightgray} \textbf{} & \textbf{Requirement} & \textbf{Simulation}  & \textbf{Experiment}   \tabularnewline \hline
		$\Delta V_{in}$ & 0.1\% & - & - \tabularnewline \hline
		$\Delta I_{L}$ & 10\% & 10\% & 9.86\% \tabularnewline \hline
		$\Delta V_{out}$  & 0.5\% & 0.5\% & 0.055\% \tabularnewline \hline
	\end{tabular}
	\caption{Voltage and current ripple.}
	\label{tab:ripple}
\end{table}

\todo{The output ripple was tested for buck mode instead of boost mode so mention here why. Stef}

\subsection{Maximum Power Point Tracking}

The proposed Perturb and Observe algorithm was simulated and also tested in the PV lab to show its real performance. The simulation was implemented in PLECS beccause this software allows to program easily the C-code for the MPPT algorithm. The results obtained showed MPPT's efficiencies higher than 99\% for the different levels of irradiance and temperature. As mention in previous chapters, the MPPT algorithm was designed with the objective of increasing the power generated by the PV panel. This was achieved in simulations together with fast MPP tracking and low oscillations around the MPP. 

Once the MPPT algorithm was working as expected, it was tested in the PV lab using the RT Box as the MPPT controller \cite{RTbox}. The RT Box received as analog inputs the voltage and current measured at the output of the PV simulator. The digital outputs of the RT Box were the PWM signals for switching the MOSFETs. 


%The test setup it is shown in figure \ref{}.


\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{2.3cm}|p{2.3cm}|p{2.3cm}|p{2.3cm}|p{2.3cm}|}
		\hline
		 \rowcolor{lightgray} & \multicolumn{2}{|c|}{ \textbf{Buck Mode}} & \multicolumn{2}{|c|}{ \textbf{Boost Mode}} \tabularnewline \hline
		\rowcolor{lightgray} \textbf{} & \textbf{Simulation}  & \textbf{Experiment} & \textbf{Simulation}  & \textbf{Experiment}  \tabularnewline \hline
		$\eta_{MPPT}$ & 99.96 \% & 97.72 \% & 99.82 \% & 97.32 \% \tabularnewline \hline
		$t_{MPPT}$ & 2 s & 10 s & 4 s & 22 s \tabularnewline \hline
		$D$  & 0.8130 & 0.7594 & 0.5900 & 0.5823 \tabularnewline \hline
	\end{tabular}
	\caption{Simulated and experimental results for the P\&O MPPT algorithm under STC.}
	\label{tab:comparisonMPPT}
\end{table}

\section{Problems and limitations}
3-Explain main problems and limitations and how are handled. Be succinct, be frank but no apologetic. Explain implications of limitations.
\subsection{Layout improvement procedure and issues, title to be improved}
opto <--x-->driver voltage levels?

inductor saturation and so

pcb hot points

...
\subsection{output cap?}
\subsection{MPPT drifting and improvement and limitations of final control algorithm}
The development of an embedded control system requires the proper working of an algorithm. During the development process, the engineer might find that the code doesn't behave as intended. A common way of supporting the debugging process consists on the use of breakpoints, where the code is stopped and the variables' value might be read. However, as this feature is not supported by the used platform, and in the case of controlling physical systems its use would be limited to simulation, alternative techniques had to be used. The adopted approach consisted on outputting the FSMs state and relevant values for the current state at every code execution loop. The 'Timestamp' field is specially important during simulation in order to track specific events at determined times. See figure \ref{console_output}.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{../Pictures/P1/Discussion/console_output.png}
		\caption{Console output.}
		\label{console_output}
	\end{center}	
\end{figure}

In initial implementations of the control algorithm, the voltage evaluation was performed in the state next to the duty cycle change. After this change, the system experiences a transient stage where the input voltage and inductor current evolve into the new steady state value. If these variables are read during the transient, the control might infer that the PV panel is in a location of the P-V curve different than where it actually is. The MPPT becomes noisier under this scenario. In order to address this issue, an additional waiting state was added to the FSM governing the system. Another solution to the issue would be to decrease the MPPT algorithm periodicity. However this solution would lead to a decrease in system's responsiveness. This drawback might be bearable by implementing a voltage controller aside from the MPPT.  

The noise in measured signals highly influenced the algorithm performance. This noise was addressed by software low pass filtering. The filter caused a dramatic improvement in signal acquisition and system response, further details are explained in the next section.

In order to develop a completely reliable algorithm further testing must be performed. These testing activities require more advanced debugging information than the console output previously shown. RT-box allows SPI communication but the testing activities would still be limited to black-box techniques. In order to reach white-box testing, the implementation would require a microcontroller instead of the RT-box. In that case, the variables' value might be directly accessed with a debugger. Also in the case of black box testing the signals are sent with a known and fixed latency in a microcontroller, which is not the case when using PLECS's console.

The implemented algorithm has more advanced functions than the simplest implementation found in introductory application notes from manufacturers, like \cite{AN1521_MC}. Among the advanced functions are tunable threshold parameters, waiting for the PV to reach open circuit voltage or variable perturb step, among others. However, this additional features add difficulty to testing activities and code comprehension. Under the development of a commercial product, it might be desirable to limit the features in order to decrease test and validation activities' cost. The decrease of the perturb variable itself consists of a FSM with 5 states with a weak coupling with the main FSM. The appropriate testing of the code requires software design and testing knowledge.

The proposed implementation has some variables which might be further optimized, like the initial value of the perturb step value, or the threshold to decrease the perturb step value. 


\subsection{Software filter}
Although the voltage and current measurement is filtered, the signal read by the control system was noisy. This noise affected the MPPT algorithm disturbing its ability to reach the MPP. Such noise might have different sources within a lab with such a big amount of hardware equipment. There are many techniques in order to address noise issues, the used technique consists on the use of digital filtering (LPF). This digital filter is a  simple code that performs the filtering at a given frequency. Being a first order filter, it was simple and fast to implement. The result can be seen in \ref{software_filter}.

\todo{cutoff frequency filter explanation}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=\textwidth]{../Pictures/P1/Discussion/sw_filter_current.png}
		\caption{Current measurement against time. Both software filtered (red) and raw (blue) signals can be seen. The filtered signal data points' size has been increased to improve readability.}
		\label{software_filter}
	\end{center}	
\end{figure}


\input{docs/discussion/coil.tex}

\input{docs/discussion/futureWork.tex}




