\chapter{Discussion}

\todo{
	**Things to avoid
	2Hyping findings-
	3Interpreting beyond what can be justified-
	4Extend in tangential topics-}

1-Intro - to be written when the section is more mature

2-What have we done:  a paragraph or two explaining the major findings and why are important.

\section{Validation of experimental results}

In this section the experimental results from the open-loop and MPPT test in section \ref{systemtest} are validated with the simulation results from section \ref{sec:componentsizing} and \ref{MPPTSimulation}.


\subsection{Open-loop simulation}

%The main losses are the dissipation from the component in heat. Also the load is a power resistor and it changes the resistance if it is in operation. So we have not a constant load at the output as in the simulation. Another reason is the dead-time of the MOSFET and therefore the duty cycle is not exactly the same value as in the simulation. belongs to the topic between efficiency simulationa and result

The table \ref{tab:ripple} compares the values of the ripples from the experiments with the values from the requirements in section \ref{sec:componentsizing} and the simulation results in appendix \ref{app:OL_ripple}. For the input ripple voltage no simulations have been carried out, since in the ideal case it is a DC voltage source and therefore no ripples can be detected. From the experimental results the signal is noisy and the ripple are to small (or cant detect)to capture values from the figure. The simulation result from the inductor and output voltage ripple have the same value as from the system requirement. This means the component have been selected correctly. For both cases the experiments result for the ripples are smaller than in the simulation. The using output capacitor is ten times oversize and so the ripple should be ten times smaller than the calculated one, as you can see in table \ref{tab:ripple}. Also the test for the output ripple was tested for buck mode instead of boost mode. This is not the worst chase for the output ripple.

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{3.5cm}|p{3cm}|p{3cm}|p{3cm}|}
		\hline
		\rowcolor{lightgray} \textbf{} & \textbf{Requirement} & \textbf{Simulation}  & \textbf{Experiment}   \tabularnewline \hline
		$\Delta V_{in}$ & 0.1\% & - & - \tabularnewline \hline
		$\Delta I_{L}$ & 10\% & 10\% & 9.86\% \tabularnewline \hline
		$\Delta V_{out}$  & 0.5\% & 0.5\% & 0.055\% \tabularnewline \hline
	\end{tabular}
	\caption{Voltage and current ripple.}
	\label{tab:ripple}
\end{table}

\todo{The output ripple was tested for buck mode instead of boost mode so mention here why. Stef}

\subsection{Maximum Power Point Tracking (MPPT)}

The proposed Perturb and Observe algorithm was simulated and also tested in the PV lab to show its real performance. The simulation was implemented in PLECS beccause this software allows to program easily the C-code for the MPPT algorithm. The results obtained showed MPPT's efficiencies higher than 99\% for the different levels of irradiance and temperature. As mention in previous chapters, the MPPT algorithm was designed with the objective of increasing the power generated by the PV panel. This was achieved in simulations together with fast MPP tracking and low oscillations around the MPP. 

Once the MPPT algorithm was working as expected, it was tested in the PV lab using the RT Box as the MPPT controller \cite{RTbox}. The RT Box received as analog inputs the voltage and current measured at the output of the PV simulator. The digital outputs of the RT Box were the PWM signals for switching the MOSFETs. The experimental setup is shown in figure \ref{testsetup}. \todo{this part should stand in experimental result and not here}

Table \ref{tab:comparisonMPPT} shows the simulated results together with the experimental results The experimental results obtained under STC show that the MPPT's efficiency is higher than 97\%. Therefore, the performance of the proposed P\&O algorithm is in the rate of the most common MPPT algorithm which varies between 96\% and 99\% \cite{MPPTResearch}. For the case of the conventional P\&O algorithm, the MPPT's efficiency is around 96\% \cite{MPPTResearch}. Hence, the modifications applied to the conventional P\&O algorithm allowed to improve the MPPT's performance. 

\begin{table}[H]
	\centering
	\begin{tabular}{|>{\centering}p{2.3cm}|p{2.3cm}|p{2.3cm}|p{2.3cm}|p{2.3cm}|}
		\hline
		 \rowcolor{lightgray} & \multicolumn{2}{|c|}{ \textbf{Buck Mode}} & \multicolumn{2}{|c|}{ \textbf{Boost Mode}} \tabularnewline \hline
		\rowcolor{lightgray} \textbf{} & \textbf{Simulation}  & \textbf{Experiment} & \textbf{Simulation}  & \textbf{Experiment}  \tabularnewline \hline
		$\eta_{MPPT}$ & 99.96 \% & 97.72 \% & 99.82 \% & 97.32 \% \tabularnewline \hline
		$t_{MPPT}$ & 2 s & 10 s & 4 s & 21 s \tabularnewline \hline
		$D$  & 0.8155 & 0.7594 & 0.5971 & 0.5823 \tabularnewline \hline
	\end{tabular}
	\caption{Simulated and experimental results for the P\&O MPPT algorithm under STC.}
	\label{tab:comparisonMPPT}
\end{table}

Comparing the experimental results with the simulated ones, from table \ref{tab:comparisonMPPT}, it is seen that the time the MPPT takes to reach the MPP is five times higher than in simulation \todo{IS IT FAST? ASK THE SUPERVISORS! Stef}. For the duty cycles, the ideal values under STC for buck and boost modes are 0.5900 and 0.8130, respectively. Comparing these values with the obtained results, it is considered accurate enough to validate the P\&O MPPT algorithm.   

\section{Problems and limitations}
3-Explain main problems and limitations and how are handled. Be succinct, be frank but no apologetic. Explain implications of limitations.
\subsection{Layout improvement procedure and issues, title to be improved}
opto <--x-->driver voltage levels?

inductor saturation and so

pcb hot points

...
\subsection{output cap?}
\subsection{MPPT drifting and improvement and limitations of final control algorithm}
The development of an embedded control system requires the proper working of an algorithm. During the development process, the engineer might find that the code doesn't behave as intended. A common way of supporting the debugging process consists on the use of breakpoints, where the code is stopped and the variables' value might be read. However, as this feature is not supported by the used platform, and in the case of controlling physical systems its use would be limited to simulation, alternative techniques had to be used. The adopted approach consisted on outputting the FSMs state and relevant values for the current state at every code execution loop. The 'Timestamp' field is specially important during simulation in order to track specific events at determined times. See figure \ref{console_output}.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{../Pictures/P1/Discussion/console_output.png}
		\caption{Console output.}
		\label{console_output}
	\end{center}	
\end{figure}

In initial implementations of the control algorithm, the voltage evaluation was performed in the state next to the duty cycle change. After this change, the system experiences a transient stage where the input voltage and inductor current evolve into the new steady state value. If these variables are read during the transient, the control might infer that the PV panel is in a location of the P-V curve different than where it actually is. The MPPT becomes noisier under this scenario. In order to address this issue, an additional waiting state was added to the FSM governing the system. Another solution to the issue would be to decrease the MPPT algorithm periodicity. However this solution would lead to a decrease in system's responsiveness. This drawback might be bearable by implementing a voltage controller aside from the MPPT.  

The noise in measured signals highly influenced the algorithm performance. This noise was addressed by software low pass filtering. The filter caused a dramatic improvement in signal acquisition and system response, further details are explained in the next section.

In order to develop a completely reliable algorithm further testing must be performed. These testing activities require more advanced debugging information than the console output previously shown. RT-box allows SPI communication but the testing activities would still be limited to black-box techniques. In order to reach white-box testing, the implementation would require a microcontroller instead of the RT-box. In that case, the variables' value might be directly accessed with a debugger. Also in the case of black box testing the signals are sent with a known and fixed latency in a microcontroller, which is not the case when using PLECS's console.

The implemented algorithm has more advanced functions than the simplest implementation found in introductory application notes from manufacturers, like \cite{AN1521_MC}. Among the advanced functions are tunable threshold parameters, waiting for the PV to reach open circuit voltage or variable perturb step, among others. However, this additional features add difficulty to testing activities and code comprehension. Under the development of a commercial product, it might be desirable to limit the features in order to decrease test and validation activities' cost. The decrease of the perturb variable itself consists of a FSM with 5 states with a weak coupling with the main FSM. The appropriate testing of the code requires software design and testing knowledge.

The proposed implementation has some variables which might be further optimized, like the initial value of the perturb step value, or the threshold to decrease the perturb step value. 


\subsection{Software filter}
Although the voltage and current measurement is filtered, the signal read by the control system was noisy. This noise affected the MPPT algorithm disturbing its ability to reach the MPP. Such noise might have different sources within a lab with such a big amount of hardware equipment. There are many techniques in order to address noise issues, the used technique consists on the use of digital filtering (LPF). This digital filter is a  simple code that performs the filtering at a given frequency. Being a first order filter, it was simple and fast to implement. The result can be seen in \ref{software_filter}.

\todo{cutoff frequency filter explanation}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=\textwidth]{../Pictures/P1/Discussion/sw_filter_current.png}
		\caption{Current measurement against time. Both software filtered (red) and raw (blue) signals can be seen. The filtered signal data points' size has been increased to improve readability.}
		\label{software_filter}
	\end{center}	
\end{figure}


\input{docs/discussion/coil.tex}

\input{docs/discussion/futureWork.tex}




